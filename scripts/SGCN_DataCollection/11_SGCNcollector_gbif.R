# Name: 
# Purpose: 
# Author: Christopher Tracey
# Created: 2016-08-11
# Updated: 2016-08-17
#
# Updates:
# insert date and info
# * 2016-08-17 - 
#
# To Do List/Future Ideas:
# * 
#---------------------------------------------------------------------------------------------

# load packages
if (!requireNamespace("arcgisbinding", quietly = TRUE)) install.packages("arcgisbinding")
  require(arcgisbinding)
if (!requireNamespace("lubridate", quietly = TRUE)) install.packages("lubridate")
  require(lubridate)
if (!requireNamespace("plyr", quietly = TRUE)) install.packages("plyr")
  require(plyr)
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
  require(here)
if (!requireNamespace("sf", quietly = TRUE)) install.packages("sf")
  require(sf)
if (!requireNamespace("rgbif", quietly = TRUE)) install.packages("rgbif")
  require(rgbif)

source(here::here("scripts","SGCN_DataCollection","0_PathsAndSettings.r"))

# read in SGCN data
db <- dbConnect(SQLite(), dbname = databasename)
SQLquery <- paste("SELECT ELCODE, SNAME, SCOMNAME, TaxaGroup, SeasonCode, ELSeason"," FROM lu_sgcn ")
lu_sgcn <- dbGetQuery(db, statement = SQLquery)
dbDisconnect(db) # disconnect the db

splist <- lu_sgcn$SNAME

# species already in Biotics
sgcnBioticsCPP <- read.csv("SGCN_bioticsCPP.csv", stringsAsFactors=FALSE)
sgcnBioticsCPP <- as.character(sgcnBioticsCPP$x)

splist <- splist[which(!splist %in% sgcnBioticsCPP)]


# gets the  keys for each species name, based on GBIF
keys <- sapply(splist, function(x) name_backbone(name=x)$speciesKey, USE.NAMES=FALSE)

# gets rid of any null values generated by name_backbone in the case of unmatchable species names
keys1=keys[-(which(sapply(keys,is.null),arr.ind=TRUE))] #note: seems to break if there is only one item in the list... use for multiple species!
cat(length(keys)-length(keys1),"of",length(keys), "species were not found in GBIF", "\n")
### add some code to put out the list of species not found in GBIF

keys <- keys1
#searches for occurrences
dat <- occ_search(
                  taxonKey=keys, 
                  limit=10000, # modify if needed, fewer will make testing go faster
                  return='data', 
                  hasCoordinate=TRUE,
                  geometry='POLYGON ((-80.577111647999971 42.018959019000079, -80.583025511999949 39.690462536000041, -77.681987232999973 39.68735201800007, -75.761816590999956 39.690666106000037, -75.678308913999956 39.790810226000076, -75.53064649099997 39.815101786000071, -75.411566911999955 39.776679135000052, -75.101245089999964 39.880029385000057, -75.09383042199994 39.944216030000064, -74.690932882999959 40.133570156000076, -74.690425973999936 40.17528313400004, -74.893196517999968 40.350896889000069, -74.914505704999954 40.415842984000051, -75.012247039999977 40.448477402000037, -75.004556583999943 40.522413349000033, -75.134560399999941 40.623471625000036, -75.136516799999981 40.723392383000032, -75.002409694999983 40.867515299000047, -75.082051382999964 40.971575944000051, -74.830463730999952 41.152763058000062, -74.768212647999974 41.271891205000031, -74.640518995999969 41.358839422000074, -74.709416559999966 41.454495330000043, -74.826329023999961 41.475865789000068, -74.936988959999951 41.521739840000066, -75.018029425999941 41.617276498000081, -75.012709979999954 41.733926517000043, -75.061642930999938 41.85481505100006, -75.218658916999971 41.904656042000056, -75.336705265999967 42.017618624000079, -77.511689405999959 42.017704281000078, -79.721693517999938 42.024739989000068, -79.715980736999938 42.353623043000027, -80.577111647999971 42.018959019000079))', # simplified boundard of Pennsylvania.
                  ##datasetKey!='4fa7b334-ce0d-4e88-aaae-2e0c138d049e' this doesnt work
                  year='1970,2019'#,
                  #fields=c('name','scientificName','datasetKey','recordedBy','key','decimalLatitude','decimalLongitude','country','basisOfRecord','coordinateAccuracy','year','month','day')
                 )

dat <-  dat[dat!="no data found, try a different search"] # deletes the items from the list where no occurences were found. doesn't work for one species
datdf <- ldply(dat) # turns the list to a data frame
write.csv(datdf, "gbif20180327backup.csv")

datdf <- subset(datdf,datasetKey!='4fa7b334-ce0d-4e88-aaae-2e0c138d049e') #subset out the records from the eBird dataset, using the ebird dataset key. Unfortunately, we need to download them first.  Might be a better way to do this somewhere.
gbifdata <- datdf # just changing the name so it backs up

#this will eventually pull up the dataset name so we can put it int tohe notes
#datasetkeys <- unique(datdf$datasetKey)
#datasetnames <- datasets(uuid="c4a2c617-91a7-4d4f-90dd-a78b899f8545")

gbifdata$Notes <- paste("gbifid=",datdf$key,"; Basis of Record=",datdf$basisOfRecord)
gbifdata$DataSource <- "GBIF"
names(gbifdata)[names(gbifdata)=='scientificName'] <- 'SNAME'
names(gbifdata)[names(gbifdata)=='key'] <- 'DataID'
names(gbifdata)[names(gbifdata)=='decimalLongitude'] <- 'Longitude'
names(gbifdata)[names(gbifdata)=='decimalLatitude'] <- 'Latitude'


gbifdata1 <- gbifdata[which(gbifdata$coordinateUncertaintyInMeters<=200),]


keeps <- c("SNAME","DataID","DataSource","Notes","Longitude","Latitude")
gbifdata <- gbifdata[keeps]

setnames(inverts_info, "Scientific_Name", "SNAME")
gbifdata <-  join(gbifdata,inverts_info,by=c('SNAME'))

# create a shapefile
# based on http://neondataskills.org/R/csv-to-shapefile-R/
# note that the easting and northing columns are in columns 5 and 6
SGCNgbif <- SpatialPointsDataFrame(gbifdata[,5:6],gbifdata,,proj4string <- CRS("+init=epsg:4326"))   # assign a CRS, proj4string = utm18nCR  #https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/OverviewCoordinateReferenceSystems.pdf; the two commas in a row are important due to the slots feature
plot(SGCNgbif,main="Map of SGCN Locations")
# write a shapefile
writeOGR(SGCNgbif, getwd(),"SGCN_FromGBIF", driver="ESRI Shapefile")


